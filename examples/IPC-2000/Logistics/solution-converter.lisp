(format t "SHOP 2.0 Solution Converter
Copyright (C) 2002  University of Maryland.
This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY
KIND, either express or implied.  This software is distributed under an
MPL/GPL/LGPL triple license.  For details, see the software source file.")

;;; Version: MPL 1.1/GPL 2.0/LGPL 2.1
;;; 
;;; The contents of this file are subject to the Mozilla Public License
;;; Version 1.1 (the "License"); you may not use this file except in
;;; compliance with the License. You may obtain a copy of the License at
;;; http://www.mozilla.org/MPL/
;;; 
;;; Software distributed under the License is distributed on an "AS IS"
;;; basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
;;; License for the specific language governing rights and limitations under
;;; the License.
;;; 
;;; The Original Code is SHOP2 Solution Converter.
;;; 
;;; The Initial Developer of the Original Code is the University of
;;; Maryland. Portions created by the Initial Developer are Copyright (C)
;;; 2000 the Initial Developer. All Rights Reserved.
;;; 
;;; Contributor(s):
;;;    Dana S. Nau
;;;    Yue Cao
;;;    Tsz-Chiu Au
;;;    Okhtay Ilghami
;;;    Ugur Kuter
;;;    Steve Mitchell
;;;    J. William Murdock
;;; 
;;; Alternatively, the contents of this file may be used under the terms of
;;; either of the GNU General Public License Version 2 or later (the "GPL"),
;;; or the GNU Lesser General Public License Version 2.1 or later (the
;;; "LGPL"), in which case the provisions of the GPL or the LGPL are
;;; applicable instead of those above. If you wish to allow use of your
;;; version of this file only under the terms of either the GPL or the LGPL,
;;; and not to allow others to use your version of this file under the terms
;;; of the MPL, indicate your decision by deleting the provisions above and
;;; replace them with the notice and other provisions required by the GPL or
;;; the LGPL. If you do not delete the provisions above, a recipient may use
;;; your version of this file under the terms of any one of the MPL, the GPL
;;; or the LGPL.

;;; -----------------------------------------------------------------------
;;;
;;; *** Solution Converter ***
;;; 
;;; The main function is solution-converter, which takes five
;;; parameters and one optional parameter
;;;
;;;   (1) a list of plans generated by SHOP2
;;;   (2) the CPU time SHOP2 takes to produce the plans
;;;   (3) the PDDL domain description
;;;   (4) the output file name, .e.g, "taxi1sol"
;;;   (5) a boolean value indicating that plans are concurrent or not.
;;;
;;; Optionally, we can specify is a list of invisible actions which
;;; is not going to present in the output plan.  It is specified by
;;; the keyword: invisible-actions.  By default, all internal operators,
;;; which begin with double exclamation marks (!!), are invisible.
;;;
;;; The output will be written to the designated output file.
;;; If there are more than one plans, each of the PDDL plans will be
;;; written to "taxi1sol-1", "taxi1sol-2", etc.
;;;
;;; *** Example ***
;;;
;;; For example, consider the taxi domain in the AIPS'02 Planning Competition.
;;; To generate a PDDL plan for the problem "taxi1", use the following commands
;;;
;;;  (multiple-value-bind (sol soltime) (find-plans 'taxi1)
;;;    (solution-converter sol soltime "taxi.pddl" "taxi1.soln" t))
;;;
;;; Then the PDDL plan will be written to "taxi1sol".
;;;
;;; Notice that if more than one plan is converted, the timing may
;;; not be correct.
;;;
;;; *** Important: The format of the SHOP2 actions ***
;;;
;;; For concurrent plan, all actions, both durative actions and non-durative
;;; actions, have two more parameters at the end of the parameter list.  The
;;; second last parameter of an action is the time stamp, and the last parameter
;;; is the duration of the action.
;;;

;;; -----------------------------------------------------------------------
;;; REVISION LOG
;;;
;;; 2002.4.13 (chiu)  If the duration of an action is smaller
;;;                   than 0.001, we print the duration with width 10.
;;;
;;; 2002.4.13 (chiu)  Set the *print-pretty* to nil.
;;;
;;; 2002.4.10 (chiu)  I fixed a bug in the procedure make-ser-action.
;;; 
;;; 2002.4.2  (chiu)  The zero cost operators are no longer invisible.
;;;                   Instead, internal operators (whose begin with !!) are
;;;                   invisible.
;;;


(setf *print-pretty* nil)

;;; creat a flat plan, a plan without hierarchical structure,
;;; and get rid of the zero cost actions and invisible actions
(defun make-flat-plan (hplan invisible-actions)
  (let ((fplan nil))
    (do* ((tt (pop hplan) (pop hplan))
          (cc (pop hplan) (pop hplan)))
         ((not cc))
      (when (and (not (and (eql (char (symbol-name (first tt)) 0) #\!)
                           (eql (char (symbol-name (first tt)) 1) #\!)))
                 (not (member (car tt) invisible-actions)))
        (push tt fplan)))
    (reverse fplan)))

;;; Translate a concurrent plan in the SHOP2 format to a structure
;;; for print-concurrent-plan.  The result of this function is a list
;;; of triples:
;;;   (1) Time stamp, (2) the action, and (3) the duration.
(defun make-plan-schedule (fplan dur-action-list ser-action-list)
  (let* ((fplan2 nil))
    (dolist (act fplan)
      (let ((act-name (read-from-string
                       (string-left-trim "!" (symbol-name (first act))))))
        (if (member act-name ser-action-list)
            (push (make-ser-action act-name act) fplan2)
            (if (member act-name dur-action-list)
                (push (make-dur-action act-name act) fplan2)
                (error "Unknown action: ~A" act)))))  ;; never occur
    fplan2))

(defun make-ser-action (head act)
  (list (nth (- (length act) 2) act)
        (reverse (cddr (reverse (cons head (cdr act)))))
        nil))

(defun make-dur-action (head act)
  (list (nth (- (length act) 2) act)
        (reverse (cddr (reverse (cons head (cdr act)))))
        (nth (- (length act) 1) act)))

;;; print a serial plan in PDDL format
(defun print-serial-plan (fplan soltime outfilename)
  (with-open-file (outfile outfilename :direction :output
                                       :if-exists :supersede)
    (let* ((i 1))
      (dolist (act fplan)
        (let ((act-name (read-from-string
                         (string-left-trim "!" (symbol-name (first act))))))
          (format outfile "~A:~A~%" i (cons act-name (cdr act)))
          (setf i (1+ i)))))
    (format outfile "Time ~A~%" (round (* soltime 1000)))))

;;; print a concurrent plan in PDDL format
(defun compare-action (a b)
  (< (first a) (first b)))

(defun print-concurrent-plan (fplan soltime dur-action-list
                              ser-action-list outfilename)
  (with-open-file (outfile outfilename :direction :output
                                       :if-exists :supersede)
    (let* ((fplan2 (make-plan-schedule fplan dur-action-list ser-action-list))
           (sorted-plan (sort fplan2 #'compare-action)))  ;; destroy fplan2
      (dolist (act sorted-plan)
        (if (null (third act))
            (format outfile "~,2F:~A~%" (first act) (second act))
            (progn
              (format outfile "~,2F:~A[~A]~%"
                (first act)
                (second act)
                (if (and (< 0 (third act)) (< (third act) 0.001))
                    (format nil "~10F" (third act))
                    (third act))
              )))))
    (format outfile "Time ~A~%" (round (* soltime 1000)))))

;;; This is the main function which translate a plan in SHOP2 format
;;; into a PDDL format.  The input parameters are 
;;;   (1) a list of plans generated by SHOP2
;;;   (2) the CPU time SHOP2 takes to produce the plans
;;;   (3) the PDDL domain description
;;;   (4) the output file name, .e.g, "taxi1sol"
;;;   (5) a boolean value indicating that plans are concurrent or not.
;;; Optionally, we can specify is a list of invisible actions which
;;; is not going to present in the output plan.  It is specified by
;;; the keyword: invisible-actions.  By default, all internal operators,
;;; which begin with double exclamation marks (!!), are invisible.

(defun solution-converter (plan-list soltime pddl-filename outfilename
                           is-it-a-concurrent-plan &key invisible-actions)

  (if is-it-a-concurrent-plan
      (format t "Converting a concurrent plan...~%")
      (format t "Converting a sequential plan...~%"))

  (let* ((is-extend-name (= (length plan-list) 1))
         (i 0))
    (when (> (length plan-list) 1)
      (format t "More than 1 plan is converted.  The timing may not be correct.~%")
    )
    (dolist (plan plan-list)
      (setf i (1+ i))
      (let* ((fplan (make-flat-plan plan invisible-actions))
             (dur-action-list nil)
             (ser-action-list nil)
             (outfilename2
               (if is-extend-name
                   outfilename
                   (concatenate 'string outfilename "-" (format nil "~A" i)))))

        ;;; Determine the list of durative action and non-durative action.
        ;;; according to the PDDL file.
        (with-open-file (infile pddl-filename :direction :input)
          (let ((pddl-domain (read infile)))
            (dolist (s pddl-domain)
              (when (and (listp s) (eql (first s) :durative-action))
                 (push (second s) dur-action-list))
              (when (and (listp s) (eql (first s) :action))
                 (push (second s) ser-action-list)))))

        (if is-it-a-concurrent-plan
            (print-concurrent-plan fplan soltime dur-action-list
                                 ser-action-list outfilename2)
            (print-serial-plan fplan soltime outfilename2)))))
  t)

;;; THE END ;;;
